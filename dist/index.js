// @bun
import{a as Q} from"./decorators.js";import"reflect-metadata";import U from"typedi";import{validationMetadatasToSchemas as V} from"class-validator-jsonschema";var W={"Access-Control-Allow-Origin":"*","Access-Control-Allow-Credentials":"*","Access-Control-Allow-Methods":"POST","Access-Control-Allow-Headers":"*"};function X(k){const w=k.CORS_HEADERS||W,F=V();return Bun.serve({port:k.port,async fetch(P){if(P.method==="OPTIONS")return new Response("Departed",{headers:w});const x=new URL(P.url);if(P.method==="PATCH"){const B=x.pathname.slice(1);if(!B&&!F[B])throw{status:404,message:`No input schema found with input name '${B}'`};return Response.json(F[B])}const G=k.routes[x.pathname];if(!G)throw{status:404,message:`Can not found path ${x.pathname}`};if(P.method==="GET")return Response.json(Q);if(!P.body||P.method!=="POST")throw new Error("Invalid Request, either use client lib or follow Bunt way!");const g=await P.json(),I=G[g.e];if(!I)throw{status:404,message:g.e+" controller not found"};const $=U.get(I),J=$?.[g.m];if(!J)throw{status:404,message:`Can not found handler under ${g.e}/${g.m}`};$.ctx={headers:P.headers,_headers:{},status:200,set:function(B){this._headers=B}};const z=await J.apply($,g.args),K={...w,...$.ctx._headers},L=$.ctx.status||200;if(typeof z==="string")return Response.json({message:z},{status:L,headers:K});return Response.json(z,{status:L,headers:K})},error(P){return Response.json({message:P.message||P,err:P},{status:P.status||400,headers:w})}})}export{X as default};
